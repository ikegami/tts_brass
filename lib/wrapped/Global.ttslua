-- ================================================================================
-- Brass: Birmingham
-- Quasi-stateless scripted version.

-- ----------------------------------------
-- Debugging commands.

-- To start a game with insufficient players, use one of the following
-- /execute start(2)
-- /execute start(3)
-- /execute start(4)

-- To make simple to step through turns quickly when debuging, use the following:
-- /execute start({ min_players = 2, skip_discard_check = true, cool_down = 0 })

-- TODO:
-- - BUG: Clients don't see their hands.
-- - BUG? Is there a race condition in the disabling of the game-advancing button?
--
-- - Add cool-down to control panel buttons (but delay them rather than dropping them)?
-- - Prevent scoring if the board fails to validate?
-- - Modify `remove_money_from_player` so that money is moved from wallet?
--   -> Timing problems?
-- - "Flash" the game-advancing button as part of announcing player turns?
--   -> How can this be done so only one person sees it?
-- - Support Income and Scores over 99?
--   -> Technically, final scores over 99 are supported.
--   -> Income over 99 is *extremely* unlikely.
--   -> Score over 99 before final scoring is *very* unlikely.
-- - Collapse similar messages into one?
-- - Keep lock and const active in prod?
--   -> error() isn't called on violation in production.

-- ================================================================================

-- Modules.
local ArrayUtils     = require("kintastic/lib/ArrayUtils")
local Const          = require("kintastic/lib/Const")
local DictUtils      = require("kintastic/lib/DictUtils")
local Iters          = require("kintastic/lib/Iters")
local Promise        = require("kintastic/lib/Promise")
local StrUtils       = require("kintastic/lib/StrUtils")
local TableLock      = require("kintastic/lib/TableLock")
local TableUtils     = require("kintastic/lib/TableUtils")
local TtsBase        = require("kintastic/lib/Promise/TtsBase")
local TtsMsgUtils    = require("kintastic/lib/TtsMsgUtils")
local TtsObject      = require("kintastic/lib/Promise/TtsObject")
local TtsObjUtils    = require("kintastic/lib/TtsObjUtils")
local TtsPlayerUtils = require("kintastic/lib/TtsPlayerUtils")
local TtsWait        = require("kintastic/lib/Promise/TtsWait")

-- Imports.
local filter                   = ArrayUtils.filter
local format_item_list         = ArrayUtils.format_item_list
local make_set                 = ArrayUtils.make_set
local push                     = ArrayUtils.push
local shuffle                  = ArrayUtils.shuffle
local const                    = Const.const
local rconst                   = Const.rconst
local select                   = DictUtils.select
local get_keys                 = DictUtils.get_keys
local merge                    = DictUtils.merge
local rmerge                   = DictUtils.rmerge
local ipairs_desc              = Iters.ipairs_desc
local ivalues                  = Iters.ivalues
local ivalues_desc             = Iters.ivalues_desc
local keys                     = Iters.keys
local sorted_ivalues           = Iters.sorted_ivalues
local values                   = Iters.values
local ends_with                = StrUtils.ends_with
local starts_with              = StrUtils.starts_with
local declare                  = TableLock.declare
local lock                     = TableLock.lock
local rlock                    = TableLock.rlock
local map                      = TableUtils.map
local spawn_object_from_data   = TtsBase.spawnObjectData
local broadcast_error          = TtsMsgUtils.broadcast_error
local broadcast_info           = TtsMsgUtils.broadcast_info
local broadcast_internal_error = TtsMsgUtils.broadcast_internal_error
local pulse_obj                = TtsMsgUtils.pulse_obj
local print_info               = TtsMsgUtils.print_info
local get_abs_height           = TtsObject.get_abs_height
local get_drop_pos             = TtsObject.get_drop_pos
local set_position             = TtsObject.setPosition
local set_position_smooth      = TtsObject.setPositionSmooth
local set_transform_smooth     = TtsObject.setTransformSmooth
local take_object              = TtsObject.takeObject
local resolve_guids            = TtsObjUtils.resolve_guids
local get_host                 = TtsPlayerUtils.get_host
local get_admins               = TtsPlayerUtils.get_admins
local get_seated_color_names   = TtsPlayerUtils.get_seated_color_names
local decolor                  = TtsPlayerUtils.decolor
local wait_condition           = TtsWait.condition

-- Forward declarations.
local init_global_data
local mega_freeze
local update_derived_game_state
local get_saved_state
local load_saved_state
local init_ui
local update_ui
local min_max_window
local cancel_announcement
local announce_player_turn
local announce_admin_turn
local advance_game
local start_game
local end_game
local start_canal_era
local end_canal_era
local start_rail_era
local end_rail_era
local end_era
local start_round
local end_round
local end_turn
local distribute_merchant_tiles
local deck_setup_canal_era
local deal_dead_card_to_players
local provide_links
local deck_setup_rail_era
local remove_link_tiles
local remove_level1_industries
local restock_beer
local get_hand_card_count
local refill_hands
local get_player_turn_index
local get_next_color_name
local determine_new_turn_order
local update_turn_order_tokens
local are_discards_full
local get_discarded_count
local clear_discarded_card
local clear_discarded_deck
local clear_discards
local add_resource_to_market
local sub_resource_from_market
local empty_spent_money
local update_bowl
local add_coin_to_bowl
local add_money_to_bowl
local give_money_to_player_announced
local sift_bowl_contents
local remove_money_from_player
local spend_money_announced
local get_track_position_offset
local move_tracker
local income_by_track_offset
local track_offset_by_income
local income_inc
local income_dec
local take_loan
local give_initial_funds
local give_income
local validate_location
local validate_link
local validate_board
local get_value_of_location_for_link
local get_value_of_link
local adjust_link_tile_value
local adjust_link_tile_values
local get_deck

-- The module.
local Mod = { }



-- ================================================================================
-- Global constants

-- Values for state.current_phase
local Phases = const(lock({
   NOT_STARTED           = 1,
   CANAL_ERA_ROUND       = 2,
   CANAL_ERA_INTER_ROUND = 3,
   CANAL_ERA_SCORE       = 4,
   INTER_ERA             = 5,
   RAIL_ERA_ROUND        = 6,
   RAIL_ERA_INTER_ROUND  = 7,
   RAIL_ERA_SCORE        = 8,
   GAME_ENDED            = 9,
}))


-- 0-based indexes for editButton.
local ButtonIndexes = const(lock({
   GB_GAME_INFO = 0,
}))


local INSUFFICIENT_FUNDS = "Insufficient funds"

-- Used to populate `objects`.
local guids = rconst(rlock({
   game_board = "4ee1f2",
   game_table = "02b512",
   game_board_area = "b1585e",
   sound_effects = "44828f",
   sound_effects_additional = "be6906",

   start_button = "0e63cb",

   -- For 2, 3, and 4 players respectively.
   card_deck_bags        = { "959e1a", "03115c", "d7877c" },
   merchant_tile_decks   = { "856fbc", "02cf54", "ce01c4" },

   play_deck_zone          = "497481",
   wild_location_deck_zone = "54a3da",
   wild_industry_deck_zone = "a3270a",

   -- Discard areas ordered left to right.
   players = {
      [ "Orange" ] = { mat = "535035", turn_order_token = "749e60", income_tracker = "42742a", score_tracker = "f890c5", discard_areas = { "2e028e", "6c9ecf" }, wallet_bowl = "f4d107", link_bag = "3fd996", canal_link = "d319a0", railway_link = "5cd3b7" },
      [ "Purple" ] = { mat = "9f5d4d", turn_order_token = "e19c38", income_tracker = "479c68", score_tracker = "fa02ec", discard_areas = { "59dfbc", "03e3a4" }, wallet_bowl = "6e1823", link_bag = "0354b2", canal_link = "3026c3", railway_link = "2b73b5" },
      [ "Teal"   ] = { mat = "c924e1", turn_order_token = "1d7a31", income_tracker = "b1dbec", score_tracker = "08f261", discard_areas = { "24b3dc", "a894b0" }, wallet_bowl = "ab3868", link_bag = "02fb12", canal_link = "b8d1b6", railway_link = "ea9667" },
      [ "Yellow" ] = { mat = "918d17", turn_order_token = "dd63fc", income_tracker = "753c24", score_tracker = "2d162b", discard_areas = { "282c08", "df91cf" }, wallet_bowl = "820239", link_bag = "219821", canal_link = "e808b2", railway_link = "80c4b1" },
   },

   player_turns = {
      { turn_order_token_zone = "471072", bowl = "456c88" },
      { turn_order_token_zone = "c962ad", bowl = "2666ed" },
      { turn_order_token_zone = "aa57da", bowl = "f8b045" },
      { turn_order_token_zone = "6bfba6", bowl = "c740af" },
   },

   coal_bag = "e54c1a",
   iron_bag = "ac9020",
   beer_bag = "6ebfd8",

   money_bags = {
      [ "Gold"   ] = "3e9524",
      [ "Silver" ] = "85f55a",
      [ "Bronze" ] = "e5d759",
   },

   -- In the order they are emptied.
   coal_market_zones = { "3c5ffd", "14aada", "ec2671", "39e20b", "56e563", "2e35ed", "6c1ee9", "bb3394", "d49b68", "14a883", "32a943", "165cc2", "1fb80c", "2ff284" },
   iron_market_zones = { "550e2a", "581ae8", "6581f5", "6c2b6d", "3bcd07", "2734e8", "0a7292", "2beec8", "ffd4d0", "ed2fdc" },

   merchants = {
      -- Oxford                       2, 3 and 4 players
      { merchant_zone = "698532", beer_zone = "3000f5" },
      { merchant_zone = "ab9bbd", beer_zone = "34fecd" },

      -- Gloucester                   2, 3 and 4 players
      { merchant_zone = "4e20da", beer_zone = "d70f79" },
      { merchant_zone = "db6a73", beer_zone = "876452" },

      -- Shrewsbury                   2, 3 and 4 players
      { merchant_zone = "dadd84", beer_zone = "8e91f0" },

      -- Warrington                      3 and 4 players
      { merchant_zone = "2b3380", beer_zone = "58bce3" },
      { merchant_zone = "88aa38", beer_zone = "12290c" },

      -- Nottingham                            4 players
      { merchant_zone = "b44318", beer_zone = "1b3e88" },
      { merchant_zone = "eefd28", beer_zone = "1f418b" },
   },

   -- Each zone is called a "location square".
   -- Using .getName() on the location square gets the name of the location.
   locations = {
      [ "Belper"           ] = { [ "Belper (West)"       ] = "86d147",
                                 [ "Belper (Central)"    ] = "30a911",
                                 [ "Belper (East)"       ] = "8dc82d" },
      [ "Birmingham"       ] = { [ "Birmingham (NW)"     ] = "33f755",
                                 [ "Birmingham (NE)"     ] = "12686f",
                                 [ "Birmingham (SW)"     ] = "ff7d65",
                                 [ "Birmingham (SE)"     ] = "efed8b" },
      [ "Burton-on-Trent"  ] = { [ "Burton-on-Trent (W)" ] = "38f370",
                                 [ "Burton-on-Trent (E)" ] = "68b7fb" },
      [ "Cannock"          ] = { [ "Cannock (West)"      ] = "00c4ea",
                                 [ "Cannock (East)"      ] = "d60870" },
      [ "Coalbrookdale"    ] = { [ "Coalbrookdale (W)"   ] = "e49be9",
                                 [ "Coalbrookdale (N)"   ] = "4cf6c2",
                                 [ "Coalbrookdale (E)"   ] = "12b206" },
      [ "Coventry"         ] = { [ "Coventry (West)"     ] = "aa5cd9",
                                 [ "Coventry (North)"    ] = "75a660",
                                 [ "Coventry (East)"     ] = "af6d14" },
      [ "Derby"            ] = { [ "Derby (West)"        ] = "cb5740",
                                 [ "Derby (North)"       ] = "789ff1",
                                 [ "Derby (East)"        ] = "3322ec" },
      [ "Dudley"           ] = { [ "Dudley (West)"       ] = "970b48",
                                 [ "Dudley (East)"       ] = "16493f" },
      [ "Kidderminster"    ] = { [ "Kidderminster (W)"   ] = "d5cc71",
                                 [ "Kidderminster (E)"   ] = "11e3b5" },
      [ "Leek"             ] = { [ "Leek (West)"         ] = "d8985b",
                                 [ "Leek (East)"         ] = "1dde98" },
      [ "Nuneaton"         ] = { [ "Nuneaton (West)"     ] = "a21200",
                                 [ "Nuneaton (East)"     ] = "cdfaf8" },
      [ "Redditch"         ] = { [ "Redditch (West)"     ] = "e1d2e8",
                                 [ "Redditch (East)"     ] = "6dd500" },
      [ "Stafford"         ] = { [ "Stafford (West)"     ] = "c23c28",
                                 [ "Stafford (East)"     ] = "cd4849" },
      [ "Stoke-on-Trent"   ] = { [ "Stoke-on-Trent (W)"  ] = "1953cc",
                                 [ "Stoke-on-Trent (N)"  ] = "b3ccc1",
                                 [ "Stoke-on-Trent (E)"  ] = "a050bc" },
      [ "Stone"            ] = { [ "Stone (West)"        ] = "53cde4",
                                 [ "Stone (East)"        ] = "8d81e6" },
      [ "Tamworth"         ] = { [ "Tamworth (West)"     ] = "40b8ca",
                                 [ "Tamworth (East)"     ] = "1dcb50" },
      [ "Northern Unnamed" ] = { [ "Northern Unnamed"    ] = "1101de" },
      [ "Southern Unnamed" ] = { [ "Southern Unnamed"    ] = "210464" },
      [ "Uttoxeter"        ] = { [ "Uttoxeter (West)"    ] = "b4887f",
                                 [ "Uttoxeter (East)"    ] = "f00e0b" },
      [ "Walsall"          ] = { [ "Walsall (West)"      ] = "f2ac6b",
                                 [ "Walsall (East)"      ] = "858ccc" },
      [ "Wolverhampton"    ] = { [ "Wolverhampton (W)"   ] = "d8b5f3",
                                 [ "Wolverhampton (E)"   ] = "313ef0" },
      [ "Worcester"        ] = { [ "Worcester (West)"    ] = "b5dd82",
                                 [ "Worcester (East)"    ] = "74f12e" },
   },

   -- Using .getName() on the link gets the name found here.
   links = {
      [ "Belper - Derby"                               ] = "67508c",
      [ "Belper - Leek"                                ] = "50cd15",
      [ "Birmingham - Coventry"                        ] = "6e89f4",
      [ "Birmingham - Dudley"                          ] = "8daa5f",
      [ "Birmingham - Nuneaton"                        ] = "628059",
      [ "Birmingham - Oxford"                          ] = "53fe28",
      [ "Birmingham - Redditch"                        ] = "3a8e4b",
      [ "Birmingham - Tamworth"                        ] = "cb87be",
      [ "Birmingham - Walsall"                         ] = "5a86d2",
      [ "Birmingham - Worcester"                       ] = "035fba",
      [ "Burton-on-Trent - Cannock"                    ] = "914cde",
      [ "Burton-on-Trent - Derby"                      ] = "e5ab74",
      [ "Burton-on-Trent - Stone"                      ] = "68cc40",
      [ "Burton-on-Trent - Tamworth"                   ] = "6dcbbf",
      [ "Burton-on-Trent - Walsall"                    ] = "4529a2",
      [ "Cannock - Stafford"                           ] = "fbe6a8",
      [ "Cannock - Northern Unnamed"                   ] = "9f31dd",
      [ "Cannock - Walsall"                            ] = "f8d409",
      [ "Cannock - Wolverhampton"                      ] = "49639b",
      [ "Coalbrookdale - Kidderminster"                ] = "08896c",
      [ "Coalbrookdale - Shrewsbury"                   ] = "5f85d7",
      [ "Coalbrookdale - Wolverhampton"                ] = "cffe8b",
      [ "Coventry - Nuneaton"                          ] = "b9d591",
      [ "Derby - Nottingham"                           ] = "b27ea5",
      [ "Derby - Uttoxeter"                            ] = "5bb5b2",
      [ "Dudley - Kidderminster"                       ] = "eafc5e",
      [ "Dudley - Wolverhampton"                       ] = "b77b35",
      [ "Gloucester - Redditch"                        ] = "b199d6",
      [ "Gloucester - Worcester"                       ] = "6b2c2c",
      [ "Kidderminster - Southern Unnamed - Worcester" ] = "4aa452",
      [ "Leek - Stoke-on-Trent"                        ] = "703509",
      [ "Nuneaton - Tamworth"                          ] = "908a01",
      [ "Redditch - Oxford"                            ] = "1576b4",
      [ "Stafford - Stone"                             ] = "e0ce81",
      [ "Stoke-on-Trent - Stone"                       ] = "a57efe",
      [ "Stoke-on-Trent - Warrington"                  ] = "a42ca0",
      [ "Stone - Uttoxeter"                            ] = "1b9c26",
      [ "Tamworth - Walsall"                           ] = "60ef3e",
      [ "Walsall - Wolverhampton"                      ] = "874549",
   },

   track_zones = {
      "f2074f", "2b8c8a", "b75c1a", "66d962", "1324f5", "37940b", "1b3c0a", "4796e2", "e04d51", "54e6a9",   --  0 ..  9
      "f9ae21", "de4170", "a12840", "aa4dd4", "0f6808", "cad61b", "a509b7", "6f2d85", "1827b2", "81c467",   -- 10 .. 19
      "b7cca3", "3f0cb2", "dbdda8", "a30e95", "d53c52", "5c080b", "664292", "521cbd", "1c0ce7", "4efb9f",   -- 20 .. 29
      "b75c8f", "b2e4d8", "cccda5", "432e13", "38bbe6", "d25ee0", "aef11e", "4c8952", "30534b", "acbfe8",   -- 30 .. 39
      "31937d", "989c9e", "bb92aa", "8d54fb", "fa3a9f", "d4bf75", "388124", "fa77cb", "cf8e95", "4cfc99",   -- 40 .. 49
      "2f99d1", "7ce05d", "7a9b26", "f57c65", "7545fe", "635261", "1ca0be", "2eadcd", "2f96ab", "17a06f",   -- 50 .. 59
      "083a7c", "80d90e", "c5369e", "052676", "bffa84", "952598", "ea7ce4", "f05e47", "cffcce", "eb1084",   -- 60 .. 69
      "58fbc3", "9a5110", "9c1585", "e9bf39", "cdb362", "3eec34", "d14f1d", "d2588c", "21bbb7", "b2a364",   -- 70 .. 79
      "38fc99", "5bf198", "97dbc2", "5a45be", "8944ae", "8b4d2f", "d36f07", "d9c3e5", "fd513a", "2ffeb2",   -- 80 .. 89
      "dfd2d8", "b9402a", "e6a17b", "ec970d", "ded76c", "f74296", "2ac41f", "065de7", "2e57c0", "710a1a",   -- 90 .. 99
   },
}))


local MAX_LINK_VALUE = 12


-- Don't lock since used as lookup.
local industry_tile_data = rconst({
   [ "Brewery I"         ] = lock({ type = "Brewery",      level = 1, count = 2, canal_era = true,  rail_era = false, cost_money =  5, cost_coal = 0, cost_iron = 1, beers_to_sell = nil, points =  4, income = 4, link_points = 2, can_develop = true  }),
   [ "Brewery II"        ] = lock({ type = "Brewery",      level = 2, count = 2, canal_era = true,  rail_era = true,  cost_money =  7, cost_coal = 0, cost_iron = 1, beers_to_sell = nil, points =  5, income = 5, link_points = 2, can_develop = true  }),
   [ "Brewery III"       ] = lock({ type = "Brewery",      level = 3, count = 2, canal_era = true,  rail_era = true,  cost_money =  9, cost_coal = 0, cost_iron = 1, beers_to_sell = nil, points =  7, income = 5, link_points = 2, can_develop = true  }),
   [ "Brewery IV"        ] = lock({ type = "Brewery",      level = 4, count = 1, canal_era = false, rail_era = true,  cost_money =  9, cost_coal = 0, cost_iron = 1, beers_to_sell = nil, points = 10, income = 5, link_points = 2, can_develop = true  }),
   [ "Coal Mine I"       ] = lock({ type = "Coal Mine",    level = 1, count = 1, canal_era = true,  rail_era = false, cost_money =  5, cost_coal = 0, cost_iron = 0, beers_to_sell = nil, points =  1, income = 4, link_points = 2, can_develop = true  }),
   [ "Coal Mine II"      ] = lock({ type = "Coal Mine",    level = 2, count = 2, canal_era = true,  rail_era = true,  cost_money =  7, cost_coal = 0, cost_iron = 0, beers_to_sell = nil, points =  2, income = 7, link_points = 1, can_develop = true  }),
   [ "Coal Mine III"     ] = lock({ type = "Coal Mine",    level = 3, count = 2, canal_era = true,  rail_era = true,  cost_money =  8, cost_coal = 0, cost_iron = 1, beers_to_sell = nil, points =  3, income = 6, link_points = 1, can_develop = true  }),
   [ "Coal Mine IV"      ] = lock({ type = "Coal Mine",    level = 4, count = 2, canal_era = true,  rail_era = true,  cost_money = 10, cost_coal = 0, cost_iron = 1, beers_to_sell = nil, points =  4, income = 5, link_points = 1, can_develop = true  }),
   [ "Cotton Mill I"     ] = lock({ type = "Cotton Mill",  level = 1, count = 3, canal_era = true,  rail_era = false, cost_money = 12, cost_coal = 0, cost_iron = 0, beers_to_sell =   1, points =  5, income = 5, link_points = 1, can_develop = true  }),
   [ "Cotton Mill II"    ] = lock({ type = "Cotton Mill",  level = 2, count = 2, canal_era = true,  rail_era = true,  cost_money = 14, cost_coal = 1, cost_iron = 0, beers_to_sell =   1, points =  5, income = 4, link_points = 2, can_develop = true  }),
   [ "Cotton Mill III"   ] = lock({ type = "Cotton Mill",  level = 3, count = 3, canal_era = true,  rail_era = true,  cost_money = 16, cost_coal = 1, cost_iron = 1, beers_to_sell =   1, points =  9, income = 3, link_points = 1, can_develop = true  }),
   [ "Cotton Mill IV"    ] = lock({ type = "Cotton Mill",  level = 4, count = 3, canal_era = true,  rail_era = true,  cost_money = 18, cost_coal = 1, cost_iron = 1, beers_to_sell =   1, points = 12, income = 2, link_points = 1, can_develop = true  }),
   [ "Iron Works I"      ] = lock({ type = "Iron Works",   level = 1, count = 1, canal_era = true,  rail_era = false, cost_money =  5, cost_coal = 1, cost_iron = 0, beers_to_sell = nil, points =  3, income = 3, link_points = 1, can_develop = true  }),
   [ "Iron Works II"     ] = lock({ type = "Iron Works",   level = 2, count = 1, canal_era = true,  rail_era = true,  cost_money =  7, cost_coal = 1, cost_iron = 0, beers_to_sell = nil, points =  5, income = 3, link_points = 1, can_develop = true  }),
   [ "Iron Works III"    ] = lock({ type = "Iron Works",   level = 3, count = 1, canal_era = true,  rail_era = true,  cost_money =  9, cost_coal = 1, cost_iron = 0, beers_to_sell = nil, points =  7, income = 2, link_points = 1, can_develop = true  }),
   [ "Iron Works IV"     ] = lock({ type = "Iron Works",   level = 4, count = 1, canal_era = true,  rail_era = true,  cost_money = 12, cost_coal = 1, cost_iron = 0, beers_to_sell = nil, points =  9, income = 1, link_points = 1, can_develop = true  }),
   [ "Manufacturer I"    ] = lock({ type = "Manufacturer", level = 1, count = 1, canal_era = true,  rail_era = false, cost_money =  8, cost_coal = 1, cost_iron = 0, beers_to_sell =   1, points =  3, income = 5, link_points = 2, can_develop = true  }),
   [ "Manufacturer II"   ] = lock({ type = "Manufacturer", level = 2, count = 2, canal_era = true,  rail_era = true,  cost_money = 10, cost_coal = 0, cost_iron = 1, beers_to_sell =   1, points =  5, income = 1, link_points = 1, can_develop = true  }),
   [ "Manufacturer III"  ] = lock({ type = "Manufacturer", level = 3, count = 1, canal_era = true,  rail_era = true,  cost_money = 12, cost_coal = 2, cost_iron = 0, beers_to_sell =   0, points =  4, income = 4, link_points = 0, can_develop = true  }),
   [ "Manufacturer IV"   ] = lock({ type = "Manufacturer", level = 4, count = 1, canal_era = true,  rail_era = true,  cost_money =  8, cost_coal = 0, cost_iron = 1, beers_to_sell =   1, points =  3, income = 6, link_points = 1, can_develop = true  }),
   [ "Manufacturer V"    ] = lock({ type = "Manufacturer", level = 5, count = 2, canal_era = true,  rail_era = true,  cost_money = 16, cost_coal = 1, cost_iron = 0, beers_to_sell =   2, points =  8, income = 2, link_points = 2, can_develop = true  }),
   [ "Manufacturer VI"   ] = lock({ type = "Manufacturer", level = 6, count = 1, canal_era = true,  rail_era = true,  cost_money = 20, cost_coal = 0, cost_iron = 0, beers_to_sell =   1, points =  7, income = 6, link_points = 1, can_develop = true  }),
   [ "Manufacturer VII"  ] = lock({ type = "Manufacturer", level = 7, count = 1, canal_era = true,  rail_era = true,  cost_money = 16, cost_coal = 1, cost_iron = 1, beers_to_sell =   0, points =  9, income = 4, link_points = 0, can_develop = true  }),
   [ "Manufacturer VIII" ] = lock({ type = "Manufacturer", level = 8, count = 2, canal_era = true,  rail_era = true,  cost_money = 20, cost_coal = 0, cost_iron = 2, beers_to_sell =   1, points = 11, income = 1, link_points = 1, can_develop = true  }),
   [ "Pottery I"         ] = lock({ type = "Pottery",      level = 1, count = 1, canal_era = true,  rail_era = true,  cost_money = 17, cost_coal = 0, cost_iron = 1, beers_to_sell =   1, points = 10, income = 5, link_points = 1, can_develop = false }),
   [ "Pottery II"        ] = lock({ type = "Pottery",      level = 2, count = 1, canal_era = true,  rail_era = true,  cost_money =  0, cost_coal = 1, cost_iron = 0, beers_to_sell =   1, points =  1, income = 1, link_points = 1, can_develop = true  }),
   [ "Pottery III"       ] = lock({ type = "Pottery",      level = 3, count = 1, canal_era = true,  rail_era = true,  cost_money = 22, cost_coal = 2, cost_iron = 0, beers_to_sell =   2, points = 11, income = 5, link_points = 1, can_develop = false }),
   [ "Pottery IV"        ] = lock({ type = "Pottery",      level = 4, count = 1, canal_era = true,  rail_era = true,  cost_money =  0, cost_coal = 1, cost_iron = 0, beers_to_sell =   1, points =  1, income = 1, link_points = 1, can_develop = true  }),
   [ "Pottery V"         ] = lock({ type = "Pottery",      level = 5, count = 1, canal_era = false, rail_era = true,  cost_money = 24, cost_coal = 2, cost_iron = 0, beers_to_sell =   2, points = 20, income = 5, link_points = 1, can_develop = true  }),
})


-- Don't lock since used as lookup.
local bonuses_by_external_location = const({
   [ "Gloucester" ] = 2,
   [ "Nottingham" ] = 2,
   [ "Oxford"     ] = 2,
   [ "Shrewsbury" ] = 2,
   [ "Warrington" ] = 2,
})


-- Initialized on load by init_global_data.
local resources              = nil
local resource_id_by_name    = nil
local loc_names_by_link_name = nil
local link_names_by_loc_name = nil
local neighbours_by_loc_name = nil


-- Initialized on load by load_saved_state.
local not_required = { }


-- ================================================================================
-- Global vars

-- IMPORTANT! Call update_derived_game_state after changing any of the attributes from which others are derived.

local is_derived = const(make_set({
   "game_started",      -- Derived from current_phase.
   "is_active_player",  -- Derived from active_players.
   "num_players",       -- Derived from active_players.
   "num_rounds",        -- Derived from num_players.
}))


local state = rlock({
   current_phase = Phases.NOT_STARTED,
   game_started  = false,
   opts          = { },
})

declare(state,
   "active_players",    -- Array of color names.
   "is_active_player",  -- Keyed by color names.
   "num_players",
   "num_rounds",
   "current_round",
   "current_player",    -- Color name.
   "game_result"
)

declare(state.opts,
   "min_players",         -- Force the game to have at least this many players.
   "skip_discard_check",  -- Don't enforce valid turns if true.
   "cool_down"            -- Length of the cool-down on the game-advancing button.
)


-- ----------------------------------------
-- Global state (not saved)

local advance_game_button_disabled = false

-- Used by update_ui to control effects.
local ui_state = { }


-- ----------------------------------------
-- Other global vars

-- Populated from `guids`.
local objects


-- ================================================================================
-- Non-UI event handlers

function Mod.onLoad(saved_state_json)
   if saved_state_json ~= "" then
      log("Loading saved game.")
      local saved_state = JSON.decode(saved_state_json)
      load_saved_state(saved_state)
   end

   init_global_data()
   mega_freeze()
   init_ui()

   for player in ivalues(Player.getPlayers()) do
      onPlayerConnect(player)
   end
end


function Mod.onSave()
   local saved_state = get_saved_state()
   if saved_state then
      local saved_state_json = JSON.encode(saved_state)
      return saved_state_json
   else
      return ""
   end
end


function Mod.onPlayerConnect(player)
   if player.steam_id == "76561198219839669" then
      if not player.admin then
         player.promote()
      end

      if not Player["Purple"].seated then
         player.changeColor("Purple")
      end
   end
end


function Mod.onChangeColor(player)
   if state.current_player == player.color then
      announce_player_turn(state.current_player)
   end
end


-- ================================================================================
-- Initialization

function init_global_data()
   objects = rlock(resolve_guids(guids, not_required))

   --

   resources = {
      coal = { resource_name = "Coal", bag = objects.coal_bag, market_zones = objects.coal_market_zones },
      iron = { resource_name = "Iron", bag = objects.iron_bag, market_zones = objects.iron_market_zones },
      beer = { resource_name = "Beer", bag = objects.beer_bag, market_zones = nil                       },
   }

   rconst(rlock(resources))

   resource_id_by_name = { }
   for resource_id, resource in pairs(resources) do
      resource_id_by_name[ resource.resource_name ] = resource_id
   end

   rconst(resource_id_by_name)

   --

   loc_names_by_link_name = { }
   link_names_by_loc_name = { }

   for loc_name in keys(objects.locations) do
      link_names_by_loc_name[loc_name] = { }
   end

   for loc_name in keys(bonuses_by_external_location) do
      link_names_by_loc_name[loc_name] = { }
   end

   for link_name, link in pairs(objects.links) do
      loc_names_by_link_name[link_name] = { }
      for loc_name in link_name:gsub(" %- ", "|"):gmatch("([^|]+)") do
         if bonuses_by_external_location[loc_name] or objects.locations[loc_name] then
            table.insert(loc_names_by_link_name[link_name], loc_name)
            table.insert(link_names_by_loc_name[loc_name], link_name)
         else
            broadcast_internal_error("Link " .. link_name .. " references unknown location " .. loc_name)
         end
      end
   end

   rconst(rlock(loc_names_by_link_name))
   rconst(rlock(link_names_by_loc_name))

   --

   neighbours_by_loc_name = { }

   for loc_name in keys(objects.locations) do
      neighbours_by_loc_name[loc_name] = { }
      for link_name in ivalues(link_names_by_loc_name[loc_name]) do
         for neighbour_name in ivalues(loc_names_by_link_name[link_name]) do
            if loc_name ~= neighbour_name then
               table.insert(neighbours_by_loc_name[loc_name], neighbour_name)
            end
         end
      end
   end

   rconst(rlock(neighbours_by_loc_name))
end


function mega_freeze()
   local objs = {
      objects.game_board,
      objects.game_table,
      objects.game_board_area,
      objects.sound_effects,
      objects.sound_effects_additional,
   }

   for obj in ivalues(objs) do
      obj.interactable = false
      obj.tooltip      = false
   end
end


-- ================================================================================
-- Game state

function update_derived_game_state()
   state.game_started = state.current_phase > Phases.NOT_STARTED

   state.is_active_player = make_set(state.active_players)

   state.num_players = #state.active_players
   state.num_rounds  = 12 - state.num_players
end


-- ================================================================================
-- Game state storage

function get_saved_state()
   if not state.game_started then
      return nil
   end

   return select(state, |k,v|not is_derived[k])
end


function load_saved_state(saved_state)
   -- Restore game state.
   rmerge(state, saved_state)
   update_derived_game_state()

   if state.game_started then
      -- Let our validation code know that some objects will be missing.
      not_required[ guids.start_button ] = true

      for i, card_deck_bag_guid in ipairs(guids.card_deck_bags) do
         if i ~= state.num_players - 1 or state.current_phase >= Phases.RAIL_ERA_ROUND then
            not_required[ card_deck_bag_guid ] = true
         end
      end

      for merchant_tile_deck_guid in ivalues(guids.merchant_tile_decks) do
         not_required[ merchant_tile_deck_guid ] = true
      end

      for color_name, player in pairs(guids.players) do
         if not state.is_active_player[color_name] then
            guids.players[color_name] = nil
         end
      end

      for i = state.num_players+1, #guids.player_turns do
         not_required[ guids.player_turns[i].turn_order_token_zone ] = true
         not_required[ guids.player_turns[i].bowl                  ] = true
      end
   end
end


-- ================================================================================
-- UI

function init_ui()
   local game_board = objects.game_board

   -- Game status label.
   -- ButtonIndexes.GB_GAME_INFO
   game_board.createButton({
      label="", click_function="on_click_dummy",
      position={ 0, 13.2, -14 }, rotation={ 0, 180, 0 }, height=0, width=0,
      font_color={ 1, 1, 1 }, font_size=400
   })

   game_board.createButton({
      label="+", click_function="on_click_add_coal_to_market",
      position={ -7.745875, 13.7634, -1.006971 }, rotation={ 0, 180, 0 }, height=300, width=300,
      font_color={ 0, 0, 0, 1 }, font_size=250
   })
   game_board.createButton({
      label="-", click_function="on_click_sub_coal_from_market",
      position={-7.745875, 13.7634, -1.566973}, rotation={ 0, 180, 0 }, height=300, width=300,
      font_color={ 0, 0, 0, 1 }, font_size=250
   })

   game_board.createButton({
      label="+", click_function="on_click_add_iron_to_market",
      position={ -10.21544, 13.84522, -1.004541 }, rotation={ 0, 180, 0 }, height=300, width=300,
      font_color={ 0, 0, 0, 1 }, font_size=250
   })
   game_board.createButton({
      label="-", click_function="on_click_sub_iron_from_market",
      position={ -10.21544, 13.84522, -1.564543 }, rotation={ 0, 180, 0 }, height=300, width=300,
      font_color={ 0, 0, 0, 1 }, font_size=250
   })

   -- Setup hook to update amount in control panel.
   for color_name, player in pairs(objects.players) do
      local bowl = player.wallet_bowl
      bowl.setTable("updateHook", {
         "Global",
         "on_wallet_bowl_update",
         { color_name = color_name },
      })
   end

   update_ui()
end


function update_ui()
   local game_info_label
   local advance_game_button_label
   local announce
   if state.current_phase == Phases.NOT_STARTED then
      game_info_label = "Click “Start Game”"
      advance_game_button_label = "Start Game"
      announce = false
   elseif state.current_phase == Phases.CANAL_ERA_ROUND then
      game_info_label = "Canal Era, Round " .. state.current_round .. " of " .. state.num_rounds
      advance_game_button_label = "End " .. state.current_player .."’s Turn"
      announce = false
   elseif state.current_phase == Phases.CANAL_ERA_INTER_ROUND then
      game_info_label = "Canal Era, Round " .. state.current_round .. " of " .. state.num_rounds
      advance_game_button_label = "Start the Next Round"
      announce = true
   elseif state.current_phase == Phases.CANAL_ERA_SCORE then
      game_info_label = "End of the Canal Era"
      advance_game_button_label = "Score the Canal Era"
      announce = true
   elseif state.current_phase == Phases.INTER_ERA then
      game_info_label = "End of the Canal Era"
      advance_game_button_label = "Start the Rail Era"
      announce = true
   elseif state.current_phase == Phases.RAIL_ERA_ROUND then
      game_info_label = "Rail Era, Round " .. state.current_round .. " of " .. state.num_rounds
      advance_game_button_label = "End " .. state.current_player .."’s Turn"
      announce = false
   elseif state.current_phase == Phases.RAIL_ERA_INTER_ROUND then
      game_info_label = "Rail Era, Round " .. state.current_round .. " of " .. state.num_rounds
      advance_game_button_label = "Start the Next Round"
      announce = true
   elseif state.current_phase == Phases.RAIL_ERA_SCORE then
      game_info_label = "End of the Rail Era"
      advance_game_button_label = "Score the Rail Era"
      announce = true
   elseif state.current_phase == Phases.GAME_ENDED then
      game_info_label = state.game_result
      advance_game_button_label = "Game Over"
      announce = true
   end

   -- Avoid repeating announces if there are no state changes.
   if announce then
      announce =
            ui_state.current_phase  ~= state.current_phase
         or ui_state.current_round  ~= state.current_round
         or ui_state.current_player ~= state.current_player
   end

   ui_state.current_phase  = state.current_phase
   ui_state.current_round  = state.current_round
   ui_state.current_player = state.current_player

   objects.game_board.editButton({ index=ButtonIndexes.GB_GAME_INFO, label=game_info_label })
   UI.setValue("advance_game_button_text", advance_game_button_label)

   local authorized
   if state.current_player then
      authorized = state.current_player
   else
      authorized = "Admin"
   end

   for color_name in keys(objects.players) do
      UI.setAttribute(color_name .. "Window", "active", state.game_started and state.is_active_player[color_name])
   end

   UI.setAttribute("advance_game_button_admin_box",  "active", authorized == "Admin")
   UI.setAttribute("advance_game_button_orange_box", "active", authorized == "Orange")
   UI.setAttribute("advance_game_button_purple_box", "active", authorized == "Purple")
   UI.setAttribute("advance_game_button_teal_box",   "active", authorized == "Teal")
   UI.setAttribute("advance_game_button_yellow_box", "active", authorized == "Yellow")

   if announce then
      announce_admin_turn()
   end
end


-- Args received: mouse_button (Uselessly "-1")
function Mod.on_mouse_enter_advance_game_button()
   UI.setAttribute("advance_game_button", "color", "#6877B3")
end


-- Args received: mouse_button (Uselessly "-1")
function Mod.on_mouse_exit_advance_game_button()
   UI.setAttribute("advance_game_button", "color", "#A9B1D3")
end


function Mod.on_click_min_max_window(player, value, id)
   min_max_window(player.color)
end


function Mod.start(opts)
   if state.game_started then return end

   if opts then
      if type(opts) == "number" then
         state.opts.min_players = opts
      else
         merge(state.opts, opts)
      end
   end

   Mod.on_click_start_game(objects.start_button, get_host().color, "-1")
end


function Mod.on_click_start_game(obj, color_name, mouse_button)
   if color_name == "Grey" or state.game_started then
      return
   end

   Mod.on_click_advance_game(Player[color_name], mouse_button, "advance_game_button")
end


function Mod.on_click_advance_game(player, mouse_button, button_id)
   if player.color == "Grey" then
      return
   end

   -- Admins can always press this button.
   if not player.admin then
      if state.current_player and Player[state.current_player].seated then
         -- Only a specific non-admin can press the button at this time.
         if player.color ~= state.current_player then
            -- This is not that player.
            broadcast_error(player.color .. ", only " .. allowed_to_advance_game .. " can advance the game at this time.", player.color)
            return
         end
      else
         -- Only an admin can press the button at this time.
         broadcast_error(player.color .. ", only the host or a promoted player can advance the game at this time.", player.color)
         return
      end
   end

   -- Disable the button until everything is done and a cool-down
   -- period (to avoid accidental clicks) is complete.
   if advance_game_button_disabled then
      return
   end

   advance_game_button_disabled = true

   local promises = { }
   table.insert(promises, advance_game())
   table.insert(promises, Promise:timeout(state.opts.cool_down or 1.5))

   Promise:all_settled(promises)
   :next(
      function(value)
         table.remove(value)  -- Ignore the timeout.
         Promise.all_settled_error_logger(value)
      end
   )
   :finally(
      function()
         advance_game_button_disabled = false
      end
   )
   :done()
end


function Mod.on_click_add_coal_to_market(obj, color_name, mouse_button)   if color_name == "Grey" then return end  add_resource_to_market(color_name, resources.coal)   end
function Mod.on_click_sub_coal_from_market(obj, color_name, mouse_button) if color_name == "Grey" then return end  sub_resource_from_market(color_name, resources.coal) end
function Mod.on_click_add_iron_to_market(obj, color_name, mouse_button)   if color_name == "Grey" then return end  add_resource_to_market(color_name, resources.iron)   end
function Mod.on_click_sub_iron_from_market(obj, color_name, mouse_button) if color_name == "Grey" then return end  sub_resource_from_market(color_name, resources.iron) end


function Mod.on_click_add1(player, value, id)
   if not state.game_started or not state.is_active_player[player.color] then return end
   give_money_to_player_announced(player.color, 1)
end


function Mod.on_click_add5(player, value, id)
   if not state.game_started or not state.is_active_player[player.color] then return end
   give_money_to_player_announced(player.color, 5)
end


function Mod.on_click_add15(player, value, id)
   if not state.game_started or not state.is_active_player[player.color] then return end
   give_money_to_player_announced(player.color, 15)
end


function Mod.on_click_pay1(player, value, id)
   if not state.game_started or not state.is_active_player[player.color] then return end
   spend_money_announced(player.color, 1)
end


function Mod.on_click_pay5(player, value, id)
   if not state.game_started or not state.is_active_player[player.color] then return end
   spend_money_announced(player.color, 5)
end


function Mod.on_click_pay15(player, value, id)
   if not state.game_started or not state.is_active_player[player.color] then return end
   spend_money_announced(player.color, 15)
end


function Mod.on_click_income_inc(player, value, id)
   if not state.game_started or not state.is_active_player[player.color] then return end
   income_inc(player.color)
end


function Mod.on_click_income_dec(player, value, id)
   if not state.game_started or not state.is_active_player[player.color] then return end
   income_dec(player.color)
end


function Mod.on_click_take_loan(player, value, id)
   if not state.game_started or not state.is_active_player[player.color] then return end
   take_loan(player.color)
end


function Mod.on_wallet_bowl_update(args)
   local value = args.value
   local color_name = args.data.color_name
   local title_id = color_name .. "Title"
   UI.setValue(title_id, "£" .. value .. " Available")
end


function Mod.on_click_dummy()
end


-- ================================================================================
-- Player's control panel window

function min_max_window(color_name)
   local window_id  = color_name .. "Window"
   local topbar_id  = color_name .. "TopBar"
   local content_id = color_name .. "Content"
   if (tonumber(UI.getAttribute(window_id, "Height")) > tonumber(UI.getAttribute(topbar_id, "Height"))) then
      UI.setAttribute(window_id, "OffsetXY", "0 85")
      UI.setAttribute(window_id, "Height", tonumber(UI.getAttribute(topbar_id, "Height")))
      UI.hide(content_id)
   else
      UI.setAttribute(window_id, "OffsetXY", "0 0")
      UI.setAttribute(window_id, "Height", 200)
      UI.show(content_id)
   end
end


-- ================================================================================
-- Announcements

local announcement_stopper

function cancel_announcement()
   if announcement_stopper then
      announcement_stopper()
      announcement_stopper = nil
   end
end


function announce_player_turn(color_name)
   cancel_announcement()
   announcement_stopper = pulse_obj(objects.players[color_name].mat, Color[color_name])
   TtsMsgUtils.announce_player_turn(color_name)
end


function announce_admin_turn()
   cancel_announcement()
   announcement_stopper = pulse_obj(objects.game_board_area, Color.Blue)
   objects.sound_effects.AssetBundle.playTriggerEffect(0)
end


-- ================================================================================
-- Game advancement

-- Initialized once the functions have been created.
local advance_game_dispatch

-- Don't lock since used as lookup.
local skip_validation = const({
   [ Phases.NOT_STARTED ] = true,
   [ Phases.INTER_ERA   ] = true,
   [ Phases.GAME_ENDED  ] = true,
})

function advance_game()
   if not advance_game_dispatch then
      advance_game_dispatch = const(lock({
         [ Phases.NOT_STARTED           ] = start_game,
         [ Phases.CANAL_ERA_ROUND       ] = end_turn,
         [ Phases.CANAL_ERA_INTER_ROUND ] = end_round,
         [ Phases.CANAL_ERA_SCORE       ] = end_canal_era,
         [ Phases.INTER_ERA             ] = start_rail_era,
         [ Phases.RAIL_ERA_ROUND        ] = end_turn,
         [ Phases.RAIL_ERA_INTER_ROUND  ] = end_round,
         [ Phases.RAIL_ERA_SCORE        ] = end_rail_era,
         [ Phases.GAME_ENDED            ] = ||Promise:resolve(),
      }))
   end

   if not skip_validation[ state.current_phase ] then
      validate_board()
   end

   return
      advance_game_dispatch[state.current_phase]()
      :finally(update_ui)
end


function start_game()
   local is_legal_color_name = make_set(get_keys(objects.players))
   local seated_color_names = get_seated_color_names()
   local everyone_seated = true
   for color_name in ivalues(seated_color_names) do
      if not is_legal_color_name[color_name] and color_name ~= "Black" and color_name ~= "Grey" then
         broadcastToColor(color_name .. ", please change your color.", color_name, color_name)
         everyone_seated = false
      end
   end

   if not everyone_seated then
      broadcast_error("All players must be seated to start. (Grey and Black permitted.)", color_name)
      return Promise:resolve()
   end

   -- Grey and Black don't count as seated players.
   seated_color_names = filter(seated_color_names, |i,color_name|is_legal_color_name[color_name])
   local is_seated_color_name = make_set(seated_color_names)

   -- Fake some players. Useful for testing.
   local num_players = #seated_color_names
   if state.opts.min_players then
      local needed_players = state.opts.min_players - num_players
      if needed_players > 0 then
         for color_name in ivalues(shuffle(get_keys(objects.players))) do
            if not is_seated_color_name[color_name] then
               is_seated_color_name[color_name] = true
               needed_players = needed_players - 1
               if needed_players == 0 then
                  break
               end
            end
         end

         -- Subtracting needed_players hedges against invalid inputs.
         num_players = state.opts.min_players - needed_players
      end
   end

   -- Make sure we have enough players, fake or otherwise.
   if num_players < 2 then
      broadcast_error("Not enough seated players.")
      return Promise:resolve()
   end

   -- Update global state.
   state.current_phase  = Phases.CANAL_ERA_ROUND
   state.active_players = get_keys(is_seated_color_name)
   state.current_round  = 1
   update_derived_game_state()

   -- Destroy the start button.
   objects.start_button.destruct()

   -- Remove absent player colors.
   for color_name, player in pairs(objects.players) do
      if not state.is_active_player[color_name] then
         player.turn_order_token.destruct()
         player.income_tracker.destruct()
         player.score_tracker.destruct()
         player.link_bag.destruct()
         player.canal_link.destruct()
         player.railway_link.destruct()
      end
   end

   -- Remove unused player turn positions.
   for i = state.num_players+1, #objects.player_turns do
      objects.player_turns[i].turn_order_token_zone.destruct()
      objects.player_turns[i].bowl.destruct()
   end

   return start_canal_era()
end


function end_game()
   state.current_phase = Phases.GAME_ENDED
   update_derived_game_state()
end


function start_canal_era()
   local promises = { }

   -- Randomize player colors.
   local turn_order = shuffle(state.active_players)
   state.current_player = turn_order[1]
   table.insert(promises, update_turn_order_tokens(turn_order))
   table.insert(promises, distribute_merchant_tiles())
   table.insert(promises,
      deck_setup_canal_era()
      :next(|deck|deal_dead_card_to_players(deck))
   )
   table.insert(promises, provide_links("canal_link", "Canals"))

   return
      Promise:all_settled(promises)
      :next(Promise.all_settled_error_logger)
      :finally(start_round)
end


function end_canal_era()
   return
      end_era()
      :finally(
         function()
            state.current_phase = Phases.INTER_ERA
            update_derived_game_state()
         end
      )
end


function start_rail_era()
   -- Update global state.
   state.current_phase = Phases.RAIL_ERA_ROUND
   state.current_round = 1
   update_derived_game_state()

   local promises = { }
   remove_link_tiles()
   remove_level1_industries()
   table.insert(promises, restock_beer())
   table.insert(promises,
      deck_setup_rail_era()
   )
   table.insert(promises, provide_links("railway_link", "Railways"))

   return
      Promise:all_settled(promises)
      :next(Promise.all_settled_error_logger)
      :finally(start_round)
end


function end_rail_era()
   return
      end_era()
      :finally(end_game)
end


function end_era()
   local link_points_by_color_name     = { ["Orange"]=0,  ["Purple"]=0,  ["Teal"]=0,  ["Yellow"]=0  }
   local industry_points_by_color_name = { ["Orange"]=0,  ["Purple"]=0,  ["Teal"]=0,  ["Yellow"]=0  }

   adjust_link_tile_values()

   for link_name, link in pairs(objects.links) do
      for obj in ivalues(link.getObjects()) do
         local name, color_name = decolor(obj.getGMNotes())
         if color_name and ( name == "Canal" or name == "Railway" ) then
            link_points_by_color_name[color_name] =
               link_points_by_color_name[color_name] +
               get_value_of_link(link_name)
         end
      end
   end

   for location in values(objects.locations) do
      for loc_square in values(location) do
         local found = false
         for obj in ivalues(loc_square.getObjects()) do
            if obj.name == "Card" then
               local name, color_name = decolor(obj.getGMNotes())
               local data = industry_tile_data[name]
               if data then
                  industry_points_by_color_name[color_name] =
                     industry_points_by_color_name[color_name] +
                     obj.getRotationValue()
               end
            end
         end
      end
   end

   local score_info_recs = { }
   for color_name in ivalues(state.active_players) do
      local player = objects.players[color_name]
      local score_tracker = player.score_tracker
      local income_tracker = player.income_tracker
      local wallet_bowl = player.wallet_bowl

      local link_points     = link_points_by_color_name[color_name]
      local industry_points = industry_points_by_color_name[color_name]
      local points          = link_points + industry_points
      local total           = get_track_position_offset(score_tracker) + points

      local income_of = get_track_position_offset(income_tracker)
      local income = income_by_track_offset(income_of)

      local money = update_bowl(wallet_bowl)

      table.insert(score_info_recs, {
         color_name      = color_name,
         link_points     = link_points,
         industry_points = industry_points,
         points          = points,
         total           = total,
         income          = income,   -- First tie-breaker
         money           = money,    -- Second tie-breaker
      })

      local num_track_zones = #objects.track_zones
      while total >= num_track_zones do total = total - num_track_zones end
      while total < 0                do total = total + num_track_zones end
   end

   -- This particular compare function returns the following:
   -- <0 if `a` placed better than `b`,
   -- >0 if `a` placed worse than `b`, or
   -- =0 if the event of a tie.
   local function compare(a, b)
      local diff = a.total - b.total
      if diff ~= 0 then
         return diff
      end

      local diff = a.income - b.income
      if diff ~= 0 then
         return diff
      end

      return a.money - b.money
   end

   table.sort(score_info_recs, |a,b|compare(a,b) > 0)

   local prev
   local ranking = 1
   local skip = 0
   local winners = { }
   for score_info_rec in ivalues(score_info_recs) do
      local color_name = score_info_rec.color_name

      if prev ~= nil then
         if compare(score_info_rec, prev) == 0 then
            skip = skip + 1
         else
            ranking = ranking + skip + 1
            skip = 0
         end
      end

      if ranking == 1 then
         table.insert(winners, color_name)
      end

      score_info_rec.ranking = ranking

      prev = score_info_rec
   end


   local promise = Promise:resolve()
   for score_info_rec in ivalues_desc(score_info_recs) do
      local color_name = score_info_rec.color_name
      local player = objects.players[color_name]
      local score_tracker = player.score_tracker

      -- We want the moves to happen seqentially because moving
      -- more than one to the same location can knock them over.
      promise = promise:next(
         function()
            local message_color = stringColorToRGB(color_name)
            printToAll(
               "#" .. score_info_rec.ranking .. ": " .. color_name .. " scored " ..
               score_info_rec.points .. " points for a total of " ..
               score_info_rec.total .. "! (" ..
               score_info_rec.link_points .. " for links, " ..
               score_info_rec.industry_points .. " for industries) ",
               message_color
            )

            return move_tracker(score_tracker, score_info_rec.total)
         end
      )

      -- We want to proceed even if an error occurs. But at the
      -- same time, we don't want to silence errors.
      promise = promise:done()
   end

   if state.current_phase == Phases.RAIL_ERA_SCORE then
      promise = promise:next(
         function()
            local result
            if #winners == #state.active_players then
               result = "Draw!"
            elseif #winners == 1 then
               local color_name = winners[1]
               local player = Player[color_name]
               local name = player.steam_name or winners[1]
               result = "Congrats to " .. name .. "!"
            else
               result = "Congrats to " .. format_item_list(winners) .. "! (Tie)"
            end

            broadcast_info(result)
            state.game_result = result
         end
      )
   end

   return promise
end


function start_round()
   local promises = { }

   local turn_order = determine_new_turn_order()
   table.insert(promises, update_turn_order_tokens(turn_order))
   state.current_player = turn_order[1]
   table.insert(promises, refill_hands(state.active_players))
   table.insert(promises, give_income())
   empty_spent_money()
   table.insert(promises, clear_discards())
   adjust_link_tile_values()

   return
      Promise:all_settled(promises)
      :next(Promise.all_settled_error_logger)
      :finally(
         function()
            if state.current_phase == Phases.CANAL_ERA_ROUND then
               print_info("Start of Canal Era Round " .. state.current_round .. " of " .. state.num_rounds .. "!")
            else
               print_info("Start of Rail Era Round " .. state.current_round .. " of " .. state.num_rounds .. "!")
            end

            announce_player_turn(state.current_player)
         end
      )
end


function end_round()
   -- Update global state.
   if state.current_phase == Phases.CANAL_ERA_INTER_ROUND then
      state.current_phase = Phases.CANAL_ERA_ROUND
   else
      state.current_phase = Phases.RAIL_ERA_ROUND
   end

   state.current_round = state.current_round + 1
   update_derived_game_state()

   return start_round()
end


function end_turn()
   -- Check if the player actually completed their turn.
   if not state.opts.skip_discard_check then
      if not are_discards_full(state.current_player) then
         local player = Player[state.current_player]
         if player.seated then
            broadcast_error(state.current_player .. ", you can’t end your turn because you don’t have 1 or 3 cards in each of your discard piles!", state.current_player)
         else
            broadcast_error("The round can’t be ended because " .. state.current_player .. " doesn’t have 1 or 3 cards in each of their discard piles!")
         end

         return Promise:resolve()
      end
   end

   local promises = { }

   table.insert(promises, refill_hands({ state.current_player }))
   adjust_link_tile_values()

   return
      Promise:all_settled(promises)
      :next(Promise.all_settled_error_logger)
      :finally(
         function()
            state.current_player = get_next_color_name()
            if state.current_player then
               announce_player_turn(state.current_player)
            else
               if state.current_round == state.num_rounds then
                  state.current_round = nil
                  if state.current_phase == Phases.CANAL_ERA_ROUND then
                     broadcast_info("End of the Canal Era!")
                     print_info("Your points will be calculated once you click the button.")
                     state.current_phase = Phases.CANAL_ERA_SCORE
                  else
                     broadcast_info("End of the Game!")
                     print_info("Your points will be calculated once you click the button.")
                     state.current_phase = Phases.RAIL_ERA_SCORE
                  end
               else
                  if state.current_phase == Phases.CANAL_ERA_ROUND then
                     broadcast_info("End of Canal Era Round " .. state.current_round .. " of " .. state.num_rounds .. "!")
                     state.current_phase = Phases.CANAL_ERA_INTER_ROUND
                  else
                     broadcast_info("End of Rail Era Round " .. state.current_round .. " of " .. state.num_rounds .. "!")
                     state.current_phase = Phases.RAIL_ERA_INTER_ROUND
                  end
               end
            end

            update_derived_game_state()
         end
      )
end


-- ================================================================================
-- Setup

-- Distribute the correct merchant tiles.
-- Destroy the rest.
function distribute_merchant_tiles()
   local promises = { }
   for i, merchant_tile_deck in ipairs(objects.merchant_tile_decks) do
      if i == state.num_players - 1 then
         merchant_tile_deck.shuffle()

         local n = #merchant_tile_deck.getObjects()
         for i = 1, n do
            local merchant_zone = objects.merchants[i].merchant_zone
            local beer_zone     = objects.merchants[i].beer_zone

            table.insert(promises,
               take_object(merchant_tile_deck, {
                  position = merchant_zone.getPosition(),
                  flip = true,
               })
               :next(
                  function(tile)
                     if starts_with(tile.getGMNotes(), "Buys ") then
                        return take_object(objects.beer_bag, {
                           position = beer_zone.getPosition(),
                        })
                     end
                  end
               )
            )
         end
      else
         merchant_tile_deck.destruct()
      end
   end

   return
      Promise:all_settled(promises)
      :next(Promise.all_settled_error_logger)
end


-- Grab the correct deck of cards.
-- Destroy the other bags of deck of cards.
function deck_setup_canal_era()
   local promise;
   local play_deck_zone = objects.play_deck_zone
   for i, card_deck_bag in ipairs(objects.card_deck_bags) do
      if i == state.num_players - 1 then
         promise =
            take_object(card_deck_bag, {
               position = play_deck_zone.getPosition(),
               rotation = play_deck_zone.getRotation(),
            })
            :next(
               function(deck)
                  deck.shuffle()
                  return deck
               end
            )
      else
         card_deck_bag.destruct()
      end
   end

   return promise
end


function deal_dead_card_to_players(deck)
   local promises = { }
   for color_name in ivalues(state.active_players) do
      table.insert(promises,
         take_object(deck, {
            position = objects.players[color_name].discard_areas[1].getPosition(),
            rotation = { 0.00, 180.00, 180.00 },
         })
         :next(
            function(card)
               card.setLock(true)
            end
         )
      )
   end

   return
      Promise:all_settled(promises)
      :next(Promise.all_settled_error_logger)
end


function provide_links(link_type, link_name)
   local promises = { }
   for color_name in ivalues(state.active_players) do
      local player = objects.players[color_name]

      local bag = player.link_bag
      bag.reset()  -- Empties it.
      bag.setName(color_name .. " " .. link_name)

      local tile = player[link_type]
      local tile_data = tile.getData()
      local pos = get_drop_pos(tile, bag)
      local y_inc = get_abs_height(tile) * 2
      pos.y = pos.y + y_inc / 2
      for i = 1, 14 do
         table.insert(promises,
            spawn_object_from_data({ data = tile_data, position = pos })
            :next(|copy|wait_condition(||copy == nil, 3, "Timeout populating link bags"))
         )
         pos.y = pos.y + y_inc
      end

      tile.destruct()
   end

   return
      Promise:all_settled(promises)
      :next(Promise.all_settled_error_logger)
end


-- Grab a fresh deck of cards.
-- Destroy the bags of deck of cards afterwards.
function deck_setup_rail_era()
   local card_deck_bag = objects.card_deck_bags[state.num_players - 1]
   local play_deck_zone = objects.play_deck_zone

   return
      take_object(card_deck_bag, {
         position = play_deck_zone.getPosition(),
         rotation = play_deck_zone.getRotation(),
      })
      :next(
         function(deck)
            deck.shuffle()
            card_deck_bag.destruct()
         end
      )
end


function remove_link_tiles()
   for link_name, link in pairs(objects.links) do
      for obj in ivalues(link.getObjects()) do
         local name = decolor(obj.getGMNotes())
         -- Railways are often used by accident.
         if name == "Canal" or name == "Railway" then
            obj.destruct()
         end
      end
   end
end


function remove_level1_industries()
   for location in values(objects.locations) do
      for loc_square in values(location) do
         local found = false
         for obj in ivalues(loc_square.getObjects()) do
            if obj.name == "Card" then
               local name = decolor(obj.getGMNotes())
               local data = industry_tile_data[name]
               if data and data.level == 1 then
                  obj.destruct()
                  found = true
               end
            end
         end

         if found then
            for obj in ivalues(loc_square.getObjects()) do
               local name = obj.getName()
               if resource_id_by_name[name] then
                  obj.destruct()
               end
            end
         end
      end
   end
end


function restock_beer()
   local promises = { }
   for merchant in ivalues(objects.merchants) do
      local merchant_zone = merchant.merchant_zone
      local beer_zone     = merchant.beer_zone

      for obj in ivalues(merchant_zone.getObjects()) do
         if starts_with(obj.getGMNotes(), "Buys ") then
            local needs_replenishing = true
            for obj in ivalues(beer_zone.getObjects()) do
               if obj.getName() == "Beer" then
                  needs_replenishing = false
                  break
               end
            end

            if needs_replenishing then
               table.insert(promises,
                  take_object(objects.beer_bag, {
                     position = beer_zone.getPosition(),
                  })
               )
            end

            break
         end
      end
   end

   return
      Promise:all_settled(promises)
      :next(Promise.all_settled_error_logger)
end


-- ================================================================================
-- Hands

-- XXX This counts all objects, not just cards. Good enough?
function get_hand_card_count(color_name)
   local player = Player[color_name]
   return #player.getHandObjects()
end


function refill_hands(color_names)
   local deck = get_deck()
   if not deck then
      return Promise:resolve()
   end

   -- Avoid failing if there are fewer cards than there should be.
   local card_count
   if deck.name == "Deck" then
      card_count = #deck.getObjects()
   else
      card_count = 1
   end

   local promises = { }
   local total_short = 0
   for color_name in ivalues(color_names) do
      local needs = 8 - get_hand_card_count(color_name)
      if needs > 0 then
         local short = 0
         if needs > card_count then
            -- Should never reach this.
            short = needs - card_count
            total_short = total_short + short
         end

         card_count = card_count - ( needs - short )
         deck.deal(( needs - short ), color_name)
         table.insert(promises,
            wait_condition(
               ||get_hand_card_count(color_name) == ( 8 - short ),
               3, ||reject("Timeout dealing cards")
            )
         )
      end
   end

   if total_short > 0 then
      broadcast_error(total_short .. " cards short! Continuing nonetheless.")
   end

   return
      Promise:all_settled(promises)
      :next(Promise.all_settled_error_logger)
end


-- ================================================================================
-- Turn order

function get_player_turn_index(color_name)
   for i = 1, state.num_players do
      local zone = objects.player_turns[i].turn_order_token_zone
      local zone_objs = zone.getObjects()
      for obj in ivalues(zone_objs) do
         local name = obj.getName()
         if ends_with(name, " Player") then
            local token_color_name = string.sub(name, 1, -1 - #" Player")
            if token_color_name == color_name then
               return i
            end

            break
         end
      end
   end

   return nil
end


function get_next_color_name()
   local found_current = false
   for i = 1, state.num_players do
      local zone = objects.player_turns[i].turn_order_token_zone
      local zone_objs = zone.getObjects()
      for obj in ivalues(zone_objs) do
         local name = obj.getName()
         if ends_with(name, " Player") then
            local token_color_name = string.sub(name, 1, -1 - #" Player")
            if token_color_name == state.current_player then
               found_current = true
            elseif found_current then
               return token_color_name
            end

            break
         end
      end
   end

   return nil
end


function determine_new_turn_order()
   local spending_data = { }
   for i = 1, state.num_players do
      local player_turn = objects.player_turns[i]

      local zone = player_turn.turn_order_token_zone
      local zone_objs = zone.getObjects()
      local color_name = nil
      for obj in ivalues(zone_objs) do
         local name = obj.getName()
         if ends_with(name, " Player") then
            color_name = string.sub(name, 1, -1 - #" Player")
            break
         end
      end

      local bowl = player_turn.bowl
      local spent = tonumber(bowl.getButtons()[1].label)
      table.insert(spending_data, { color_name = color_name, spent = spent, orig_pos = i })
   end

   table.sort(spending_data,
      function(a, b)
         if a.spent ~= b.spent then
            return a.spent < b.spent
         end

         return a.orig_pos < b.orig_pos
      end
   )

   return map(spending_data, |_|_.color_name)
end


function update_turn_order_tokens(turn_order)
   local promises = { }
   for player_num, color_name in ipairs(turn_order) do
      local zone = objects.player_turns[player_num].turn_order_token_zone
      local token = objects.players[color_name].turn_order_token
      table.insert(promises,
         set_position_smooth(token, zone.getPosition())
         :catch(||error("Error moving turn order token"))
      )
   end

   return
      Promise:all_settled(promises)
      :next(Promise.all_settled_error_logger)
end


-- ================================================================================
-- Discard pile manipulations

function are_discards_full(color_name)
   for i = 1, 2 do
      local count = get_discarded_count(color_name, i)
      if count ~= 1 and count ~= 3 then
         return false
      end
   end

   return true
end


function get_discarded_count(color_name, idx)
   local discard_area = objects.players[color_name].discard_areas[idx]
   local count = 0
   for obj in ivalues(discard_area.getObjects()) do
      if obj.name == "Card" then
         count = count + 1
      elseif obj.name == "Deck" then
         for obj in ivalues(obj.getObjects()) do
            count = count + 1
         end
      end
   end

   return count
end


function clear_discarded_card(card)
   local id = card.getGMNotes()
   if id == "Wild Location Card" then
      card.setLock(false)
      return
         set_transform_smooth(card, {
            position = objects.wild_location_deck_zone.getPosition(),
            rotation = objects.wild_location_deck_zone.getRotation(),
         })
         :catch(||error("Error moving wild location card"))
   elseif id == "Wild Industry Card" then
      card.setLock(false)
      return
         set_transform_smooth(card, {
            position = objects.wild_industry_deck_zone.getPosition(),
            rotation = objects.wild_industry_deck_zone.getRotation(),
         })
         :catch(||error("Error moving wild industry card"))
   else
      card.destruct()
      return Promise:resolve()
   end
end


function clear_discarded_deck(deck)
   local promises = { }
   local pos = deck.getPosition()
   local inc = Vector({ 0, 0.2, 0 })
   for i = 1, #deck.getObjects() do
      pos = pos + inc
      table.insert(promises,
         take_object(deck, {
            index = 1,
            position = pos,
         })
         :next(clear_discarded_card)
      )
   end

   return
      Promise:all_settled(promises)
      :next(Promise.all_settled_error_logger)
end


function clear_discards()
   if state.current_phase == Phases.CANAL_ERA_ROUND and state.current_round == 1 then
      return
   end

   local promises = { }
   for color_name in ivalues(state.active_players) do
      for discard_area in ivalues(objects.players[color_name].discard_areas) do
         for obj in ivalues(discard_area.getObjects()) do
            if obj.name == "Card" then
               table.insert(promises, clear_discarded_card(obj))
            elseif obj.name == "Deck" then
               table.insert(promises, clear_discarded_deck(obj))
            end
         end
      end
   end

   return
      Promise:all_settled(promises)
      :next(Promise.all_settled_error_logger)
end


-- ================================================================================
-- Coal and iron market manipulations

function add_resource_to_market(color_name, resource)
   for i, zone in ipairs_desc(resource.market_zones) do
      local zone_objs = zone.getObjects()
      local has_resource = false
      for obj in ivalues(zone_objs) do
         if obj.getName() == resource.resource_name then
            has_resource = true
            break
         end
      end

      if not has_resource then
         local value = math.floor((i+1) / 2)
         resource.bag.takeObject({ position=zone.getPosition(), smooth=false })
         printToAll(color_name .. " added " .. resource.resource_name .. " valued at £" .. value .. ".", color_name)
         break
      end
   end
end


function sub_resource_from_market(color_name, resource)
   for i, zone in ipairs(resource.market_zones) do
      local zone_objs = zone.getObjects()
      local had_resource = false
      for obj in ivalues(zone_objs) do
         if obj.getName() == resource.resource_name then
            obj.destruct()
            local value = math.floor((i+1) / 2)
            printToAll(color_name .. " removed " .. resource.resource_name .. " valued at £" .. value .. ".", color_name)
            had_resource = true
            break
         end
      end

      if had_resource then
         break
      end
   end
end


-- ================================================================================
-- Money.

function empty_spent_money()
   for i = 1, state.num_players do
      objects.player_turns[i].bowl.call("empty")
   end
end


function update_bowl(bowl)
   return bowl.call("countItems")
end


function add_coin_to_bowl(bowl, coin_name)
   local pos   = bowl.getPosition()
   local scale = bowl.getScale()
   local range = scale.x * 0.8
   pos.x = pos.x + math.random() * range * 2 - range
   pos.y = pos.y + scale.y * 2.25
   pos.z = pos.z + math.random() * range * 2 - range

   local bag = objects.money_bags[coin_name]
   return take_object(bag, {
      position = pos,
      rotation = { 0, 180, 0 },
      smooth   = false,
   })
end


-- `amount` must be non-negative.
function add_money_to_bowl(bowl, amount)
   local promises = { }
   while amount >= 15 do table.insert(promises, add_coin_to_bowl(bowl, "Gold"))    amount = amount - 15 end
   while amount >=  5 do table.insert(promises, add_coin_to_bowl(bowl, "Silver"))  amount = amount -  5 end
   while amount >=  1 do table.insert(promises, add_coin_to_bowl(bowl, "Bronze"))  amount = amount -  1 end

   return
      Promise:all_settled(promises)
      :next(Promise.all_settled_error_logger)
      :finally(
         function()
            update_bowl(bowl)
         end
      )
end


-- `amount` must be non-negative.
function give_money_to_player_announced(color_name, amount)
   local wallet_bowl = objects.players[color_name].wallet_bowl
   add_money_to_bowl(wallet_bowl, amount)
   :finally(
      function()
         printToAll(color_name .. " received £" .. amount .. ".", color_name)
      end
   )
   :done()
end


-- This only works if there can't be stacks of coins.
function sift_bowl_contents(bowl_contents)
   local coins = {
      [ "Gold"   ] = { },
      [ "Silver" ] = { },
      [ "Bronze" ] = { },
   }

   for obj in ivalues(bowl_contents) do
      local name = obj.getName()
      if coins[name] then
         table.insert(coins[name], obj)
      end
   end

   return coins
end


-- amount must be non-negative.
-- Primarily, we want to create the fewest coins possible.
-- Secondarily, we want to remove the most coins possible.
function remove_money_from_player(color_name, amount, spent)
   local wallet_bowl = objects.players[color_name].wallet_bowl
   if amount == 0 then
      return Promise:resolve()
   end

   local initial_total = update_bowl(wallet_bowl)
   local final_total = initial_total + amount
   if initial_total < amount then
      return Promise:reject(INSUFFICIENT_FUNDS)
   end

   local spent_bowl
   if spent then
      local player_turn_index = get_player_turn_index(color_name)
      if player_turn_index then
         spent_bowl = objects.player_turns[player_turn_index].bowl
      else
         error("Can’t find turn order token for " .. color_name)
      end
   end

   local ones = amount
   local fifteens = math.floor(ones / 15)
   ones = ones - fifteens * 15
   local fives = math.floor(ones / 5)
   ones = ones - fives * 5

   local bowl_contents = wallet_bowl.getTable("itemsInBowl")
   local coins = sift_bowl_contents(bowl_contents)
   local coin_counts = map(coins, |_|#_)

   -- ----------
   -- Bronze

   -- Make change if necessary.
   if coin_counts[ "Bronze" ] < ones then
      if coin_counts["Silver"] >= 1 then
         coin_counts[ "Silver" ] = coin_counts[ "Silver" ] - 1
         coin_counts[ "Bronze" ] = coin_counts[ "Bronze" ] + 5
      elseif coin_counts["Gold"] >= 1 then
         coin_counts[ "Gold"   ] = coin_counts[ "Gold"   ] - 1
         coin_counts[ "Silver" ] = coin_counts[ "Silver" ] + 2
         coin_counts[ "Bronze" ] = coin_counts[ "Bronze" ] + 5
      end
   end

   coin_counts[ "Bronze" ] = coin_counts[ "Bronze" ] - ones

   -- ----------
   -- Silver

   -- Get rid of the most coins possible to avoid overflowing.
   while fives >= 1 and coin_counts[ "Bronze" ] >= 5 do
      coin_counts[ "Bronze" ] = coin_counts[ "Bronze" ] - 5
      fives = fives - 1
   end

   -- Make change if necessary.
   if coin_counts[ "Silver" ] < fives then
      if coin_counts["Gold"] >= 1 then
         coin_counts[ "Gold"   ] = coin_counts[ "Gold"   ] - 1
         coin_counts[ "Silver" ] = coin_counts[ "Silver" ] + 3
      end
   end

   coin_counts[ "Silver" ] = coin_counts[ "Silver" ] - fives

   -- ----------
   -- Gold

   -- Get rid of the most coins possible to avoid overflowing.
   while fifteens >= 1 and coin_counts[ "Bronze" ] >= 15 do
      coin_counts[ "Bronze" ] = coin_counts[ "Bronze" ] - 15
      fifteens = fifteens - 1
   end

   if fifteens >= 1 then
      if coin_counts[ "Silver" ] >= 1 and coin_counts[ "Bronze" ] >= 10 then
         coin_counts[ "Silver" ] = coin_counts[ "Silver" ] - 1
         coin_counts[ "Bronze" ] = coin_counts[ "Bronze" ] - 10
         fifteens = fifteens - 1
      elseif coin_counts[ "Silver" ] >= 2 and coin_counts[ "Bronze" ] >= 5 then
         coin_counts[ "Silver" ] = coin_counts[ "Silver" ] - 2
         coin_counts[ "Bronze" ] = coin_counts[ "Bronze" ] - 5
         fifteens = fifteens - 1
      end
   end

   while fifteens >= 1 and coin_counts[ "Silver" ] >= 3 do
      coin_counts[ "Silver" ] = coin_counts[ "Silver" ] - 3
      fifteens = fifteens - 1
   end

   coin_counts[ "Gold" ] = coin_counts[ "Gold" ] - fifteens

   -- ----------
   -- Reconcilation

   local promises = { }
   for coin_name in ivalues({ "Gold", "Silver", "Bronze" }) do
      local diff = coin_counts[coin_name] - #coins[coin_name]
      if diff < 0 then   -- If there are more coins then there should be.
         local to_remove = -diff
         for i = 1, to_remove do
            table.remove(coins[coin_name]).destruct()
         end
      elseif diff > 0 then   -- If there are fewer coins then there should be.
         local to_add = diff
         for i = 1, to_add do
            table.insert(promises, add_coin_to_bowl(wallet_bowl, coin_name))
         end
      end
   end

   if spent_bowl then
      table.insert(promises, add_money_to_bowl(spent_bowl, amount))
   end

   return
      Promise:all_settled(promises)
      :next(Promise.all_settled_error_logger)
      :finally(
         function()
            update_bowl(wallet_bowl)
            if spent_bowl then
               update_bowl(spent_bowl)
            end
         end
      )
end


-- amount must be non-negative.
function spend_money_announced(color_name, amount)
   remove_money_from_player(color_name, amount, true)
   :next(
      function(result)
         printToAll(color_name .. " payed £" .. amount .. ".", color_name)
      end,
      function(reason)
         if reason == INSUFFICIENT_FUNDS then
            broadcast_error(color_name .. ", you don’t not have enough money to pay £" .. amount .. ".", color_name)
         else
            broadcast_error("Error trying to pay " .. amount .. ": " .. reason)
         end
      end
   )
end


-- ================================================================================
-- Income.

-- Used for both the income tracker and the score tracker.
function get_track_position_offset(tracker)   -- 0-based
   for i, zone in ipairs(objects.track_zones) do
      for obj in ivalues(zone.getObjects()) do
         if obj == tracker then
            return i-1
         end
      end
   end

   return nil
end


-- Used for both the income tracker and the score tracker.
function move_tracker(tracker, ofs, instant)   -- 0-based
   local zone = objects.track_zones[ofs+1]
   local pos = get_drop_pos(tracker, zone)
   pos.y = pos.y - get_abs_height(tracker) / 2   -- Make sure it's at least partially in the zone.
   if instant then
      return set_position(tracker, pos)
   else
      return
         set_position_smooth(tracker, pos)
         :catch(||error("Error moving tracker"))
   end
end


function income_by_track_offset(ofs)   -- 0-based
   if     ofs <=  10 then return math.modf( ( ofs -  0 ) / 1 ) + -10
   elseif ofs <=  30 then return math.modf( ( ofs - 11 ) / 2 ) +   1
   elseif ofs <=  60 then return math.modf( ( ofs - 31 ) / 3 ) +  11
   elseif ofs <= 100 then return math.modf( ( ofs - 61 ) / 4 ) +  21
   else                   return 30
   end
end


-- Gives the top spot of group.
function track_offset_by_income(income)   -- 0-based
   if     income <=  0 then return ( income - -10 ) * 1 +  0
   elseif income <= 10 then return ( income -   1 ) * 2 + 12
   elseif income <= 20 then return ( income -  11 ) * 3 + 33
   else                     return ( income -  21 ) * 4 + 64
   end
end


function income_inc(color_name)
   local player = objects.players[color_name]
   local tracker = player.income_tracker
   local old_ofs = get_track_position_offset(tracker)

   local new_ofs
   if old_ofs == 99 then
      new_ofs = 0
   else
      new_ofs = old_ofs + 1
   end

   move_tracker(tracker, new_ofs, true)
   :finally(
      function()
         printToAll(color_name .. " increased their income by one position to " .. new_ofs .. " (from " .. old_ofs .. ").", color_name)
      end
   )
   :done()
end


function income_dec(color_name)
   local player = objects.players[color_name]
   local tracker = player.income_tracker
   local old_ofs = get_track_position_offset(tracker)
   local new_ofs = old_ofs - 1

   if new_ofs < 0 then
      broadcast_error(color_name .. ", you can’t reduce your income any further as it is already at the minimum!", color_name)
      return
   end

   move_tracker(tracker, new_ofs, true)
   :finally(
      function()
         printToAll(color_name .. " reduced their income to position " .. new_ofs .. " (from " .. old_ofs .. ").", color_name)
      end
   )
   :done()
end


function take_loan(color_name)
   local player = objects.players[color_name]
   local tracker = player.income_tracker
   local wallet_bowl = player.wallet_bowl

   local old_ofs = get_track_position_offset(tracker)
   local income = income_by_track_offset(old_ofs)

   income = income - 3
   if income < -10 then
      broadcast_error(color_name .. ", you can’t take out a loan as you would exceed 10 interest!", color_name)
      return
   end

   local promises = { }
   local new_ofs = track_offset_by_income(income)
   table.insert(promises, move_tracker(tracker, new_ofs, true))
   table.insert(promises, add_money_to_bowl(wallet_bowl, 30))

   Promise:all_settled(promises)
   :next(Promise.all_settled_error_logger)
   :finally(
      function()
         printToAll(color_name .. " took a loan. They gained £30 and their income was decreased by three steps to " .. income .. " (from position " .. old_ofs .. ").", color_name)
      end
   )
   :done()
end


function give_initial_funds()
   local promises = { }
   for color_name in ivalues(state.active_players) do
      local wallet_bowl = objects.players[color_name].wallet_bowl
      table.insert(promises, add_money_to_bowl(wallet_bowl, 17))
   end

   return
      Promise:all_settled(promises)
      :next(Promise.all_settled_error_logger)
end


function give_income()
   if state.current_phase == Phases.CANAL_ERA_ROUND and state.current_round == 1 then
      return give_initial_funds()
   end

   local incomes = { }
   for i, zone in ipairs(objects.track_zones) do
      for obj in ivalues(zone.getObjects()) do
         local name = obj.getName()
         if ends_with(name, " Income Tracker") then
            color_name = string.sub(name, 1, -1 - #" Income Tracker")
            incomes[color_name] = income_by_track_offset(i-1)
         end
      end
   end

   local promises = { }
   for color_name in ivalues(state.active_players) do
      table.insert(promises, Promise:new(
         function(resolve, reject)
            local player = objects.players[color_name]
            local wallet_bowl = player.wallet_bowl
            local income = incomes[color_name]
            local remaining = income
            if income == nil then
               reject("No income tracker found for " .. color_name)
            elseif income < 0 then
               resolve(
                  remove_money_from_player(color_name, -income, false)
                  :next(
                     function(result)
                        broadcastToAll(color_name .. " lost £" .. (-income) .. " to interest!", color_name)
                     end,
                     function(reason)
                        if reason == INSUFFICIENT_FUNDS then
                           broadcast_error(color_name .. " doesn’t have enough money to cover the interest of £" .. (-income) .. "!")
                        else
                           broadcast_error("Error trying to pay " .. amount .. ": " .. reason)
                        end
                     end
                  )
               )
            elseif income > 0 then
               resolve(
                  add_money_to_bowl(wallet_bowl, income)
                  :finally(
                     function()
                        broadcastToAll(color_name .. " gained £" .. income .. " in income!", color_name)
                     end
                  )
               )
            else
               broadcastToAll(color_name .. " did not earn any income.", color_name)
               resolve()
            end
         end
      ))
   end

   return
      Promise:all_settled(promises)
      :next(Promise.all_settled_error_logger)
end


-- ================================================================================
-- Board validation

function validate_link(link_name)
   local link = objects.links[link_name]
   local found = false
   for obj in ivalues(link.getObjects()) do
      local name = decolor(obj.getGMNotes())
      if obj.name == "Custom_Tile" and ( name == "Canal" or name == "Railway" ) then
         if found then
            broadcast_error("Unexpected object found for link " .. link_name .. "!")
            return false
         end

         found = true
      elseif obj == objects.game_board or obj == objects.game_table then
         -- Ignore the game board and the game table.
      else
         broadcast_error("Unexpected object found for link " .. link_name .. "!")
         return false
      end
   end
end


function validate_location(loc_name)
   if bonuses_by_external_location[loc_name] then
      return true
   end

   local tiles = { }

   local location = objects.locations[loc_name]
   for loc_square_name, loc_square in pairs(location) do
      local found = false
      for obj in ivalues(loc_square.getObjects()) do
         if obj.name == "Card" then
            local name = decolor(obj.getGMNotes())
            local tile_data = industry_tile_data[name]
            if tile_data then
               if found or tiles[obj] then
                  broadcast_error("Unexpected object found at " .. loc_square_name .. "!")
                  return false
               end

               found = true
               tiles[obj] = true  -- Check for tiles that span more than one location.
            end
         elseif resource_id_by_name[ obj.getName() ] then
            -- Ignore Coal, Iron and Beer.
         elseif obj == objects.game_board or obj == objects.game_table then
            -- Ignore the game board and the game table.
         else
            broadcast_error("Unexpected object found at " .. loc_square_name .. "!")
            return false
         end
      end
   end

   return true
end


function validate_board()
   for link_name in keys(objects.links) do
      validate_link(link_name)
   end

   for loc_name in keys(objects.locations) do
      validate_location(loc_name)
   end
end



-- ================================================================================
-- Link state calculation

-- Doesn't validate.
function get_value_of_location_for_link(loc_name)
   if bonuses_by_external_location[loc_name] then
      return bonuses_by_external_location[loc_name]
   end

   local location = objects.locations[loc_name]
   local value = 0
   for loc_square in values(location) do
      for obj in ivalues(loc_square.getObjects()) do
         if obj.name == "Card" then
            local name = decolor(obj.getGMNotes())
            local tile_data = industry_tile_data[name]
            if tile_data and obj.is_face_down then
               value = value + tile_data.link_points
            end
         end
      end
   end

   return value
end


-- Doesn't validate.
function get_value_of_link(link_name)
   local value = 0
   for loc_name in ivalues(loc_names_by_link_name[link_name]) do
      value = value + get_value_of_location_for_link(loc_name)
   end

   return value
end


-- Doesn't validate.
function adjust_link_tile_value(link_name)
   local link = objects.links[link_name]
   for obj in ivalues(link.getObjects()) do
      local name = decolor(obj.getGMNotes())
      if obj.name == "Custom_Tile" and ( name == "Canal" or name == "Railway" ) then
         local value = get_value_of_link(link_name)
         local state_id
         if value == 0 then
            state_id = MAX_LINK_VALUE + 1
         elseif value > MAX_LINK_VALUE then
            -- Hmmm, we got a higher value than we expect to be possible.
            -- It will still be scored correctly.
            state_id = MAX_LINK_VALUE
         else
            state_id = value
         end

         if state_id and state_id ~= obj.getStateId() then
            obj.setState(state_id)
         end
      end
   end
end


-- Doesn't validate.
function adjust_link_tile_values()
   for link_name in keys(objects.links) do
      adjust_link_tile_value(link_name)
   end
end


-- ================================================================================
-- Misc

function get_deck()
   local deck
   local card_count
   for obj in ivalues(objects.play_deck_zone.getObjects()) do
      if obj.name == "Deck" or obj.name == "Card" then
         return obj
      end
   end
end


function all_settled_error_logger(value)
   for result in ivalues(value) do
      if result.status == "rejected" then
         broadcast_error(result.reason)
      end
   end

   return value
end


-- ================================================================================

return Mod
